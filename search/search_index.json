{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to StemmaBench","text":"<p>A powerful and easy to use Python library to generate artificial manuscript tradition, by simulating scribal behavior in order to benchmark stemmatology algorithms. You can simply generate a tradition, apply your stemmatology algorithms on the generated texts, and assess how well your tree was reconstructed compared to the ground truth.</p>"},{"location":"#installing","title":"Installing","text":"<p>Stemmabench is available on PyPi:</p> <p><code>pip install stemmabench</code></p> <p>You can also clone the source code if you want access to the demonstration folder, then install it using in the root folder:</p> <p><code>invoke install</code></p>"},{"location":"#using-stemmabench","title":"Using StemmaBench","text":"<p>StemmaBench requires two items:</p> <ul> <li> <p>The initial text to be copied by the artificial scribe.</p> </li> <li> <p>A YAML configuration file parametrizing the variants. For more information regarding the configuration file, go to the variant description page.</p> </li> </ul> <p>Once you have your wanted text and wanted configuration file, you can run the command:</p> <pre><code>generate input.txt output_folder config.yaml\n</code></pre> <p>This will output the generated text as well as the tree structure in the folder <code>output_folder</code>.</p> <p>Demonstration data is available in the folder <code>./demo</code>.</p>"},{"location":"about/","title":"About the project","text":""},{"location":"about/#funding","title":"Funding","text":"<p>StemmaBench is funded by the SCRIBES (Biblissima+) and the SHERBET (ANR AAPG 2023) projects.</p>"},{"location":"about/#developers","title":"Developers","text":"<p>The main developer is Sophie Robert, a postdoctoral researcher @ the University of Lorraine, at the Ecritures laboratory. She is currently working on computational stemmatology to study the transmission of the Hebrew Bible. For further inquiry or collaboration, she can be contacted at sophie.robert2@etu.univ-lorraine.fr.</p> <p>A huge thanks to Yedidia Agnimo for his contribution to the development of the Python package.</p>"},{"location":"algorithms/","title":"How to use","text":"<p>In order to construct a stemma in the stemmabench package, a <code>Stemma</code> object must be created, which stores all relevant information about the stemma. A stemma can be constructed in one of two ways:</p> <ul> <li>From an edge file containing all the edges present in the stemma</li> <li>Using one of the implemented algorithms in the stemmabench package</li> </ul> <p>For both methods, the stemma object must be initialized with the path to the folder containing all the stemma texts. <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\n</code></pre> The stemmas can then be built by calling the compute method on the stemma object.</p>"},{"location":"algorithms/#build-stemma-from-edge-file","title":"Build stemma from edge file","text":"<p>A stemma can be built from a txt file containing the list of all the edges contained in the stemma. This txt file must be present in the folder path specified in the stemma constructor.</p> <p>The format of the edge file must be as follows:</p> <pre><code>(2, 5)\n(2, 6)\n(root, 2)\n(root, 3)\n(root, 4)\n(3, 7)\n(3, 8)\n(3, 9)\n(4, 10)\n(4, 11)\n(4, 12)\n(4, 13)\n</code></pre> <p>[Note]</p> <p>For an edge file to be valid, it must possess only one root. The root is defined as the label that only appears on the left side of all the edges, as shown in the example above. The order of the labels in each edge is important and represents (parent, child).</p> <p>The labels present in the edges must have matching txt files in the specified folder path containing the corresponding manuscript text. If the txt file does not exist, the node will be considered as empty. That is to say, a node with no text.</p> <p>To build a stemma from an edge file, simply instantiate the stemma, taking care to specify the folder containing the edge file. Then call the compute method, specifying the name of the edge file.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(edge_file=\"edge_file.txt\")\n</code></pre>"},{"location":"algorithms/#build-stemma-from-using-implemented-algorithms","title":"Build stemma from using implemented algorithms","text":"<p>In the stemmabench package, algorithms are implemented in the form of objects that perform the stemma tree construction. The result of the compute method called on these algorithm objects is the root of the stemma that is passed to the stemma object.</p> <p>All parameters specific to each algorithm are passed in the algorithm object constructor.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(algo=StemmaDummy(width = 2))\n</code></pre> <p>The extra arguments to be passed to the algorithm's compute method can be passed in the <code>**kwargs</code> of the stemma compute method.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(algo=StemmaDummy(), width = 2)\n</code></pre> <p>For further details on the algorithm objects and their parameters, check the Implemented algorithms section.</p>"},{"location":"algorithms/#saving-the-results-of-a-stemma","title":"Saving the results of a stemma","text":"<p>A stemma can be saved using the <code>dump</code> method. This method will create a txt file for each manuscript present in the stemma (manuscript_label.txt), as well as an edge file listing all the edges present in the tree. If the specified folder does not exist, it will be created.</p> <p>The specific name of the edge file can be specified using the edge_file_name parameter.</p> <p>If the parameter dump_texts is set to false, only the edge file will be created.</p> <pre><code>stemma.dump(folder=\"path_to_the_folder\", edge_file_name=\"my_edges.txt\", dump_texts=False)\n</code></pre>"},{"location":"algorithms/#implemented-algorithms","title":"Implemented algorithms","text":"<p>The following algorithms are currently implemented in the package:</p> <ul> <li>Dummy</li> <li>Neighbor-Joining</li> <li>RHM (Experimental)</li> </ul>"},{"location":"algorithms/#dummy","title":"Dummy","text":"<p>This algorithm constructs random stemmas that respect certain constraints. The stemmas produced by this algorithm are meant to be used as a baseline to gauge the performance of various other stemmatological algorithms against random attribution. The algorithm will fill the tree structure from top to bottom and from left to right until all the manuscripts have been placed in the tree structure.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(algo=StemmaDummy(width = 2, seed = 1))\n</code></pre>"},{"location":"algorithms/#parameters","title":"Parameters","text":"<ul> <li><code>width</code>: The number of children of each manuscript in the tree.</li> <li><code>seed</code>: The seed that is passed to a random number generator in order to produce reproducible results.</li> </ul>"},{"location":"algorithms/#neighbor-joining","title":"Neighbor-Joining","text":"<p>The Neighbor-Joining algorithm functions similarly to the agglomerative hierarchical clustering method, in that it requires a distance or similarity metric in order to progressively group individuals together.</p> <p>Neighbor-Joining, being a distance or dissimilarity-based algorithm, therefore requires a choice of metric to calculate a distance matrix representing the distance between each pair of texts.</p> <p>This method can only produce bifid trees with existing manuscripts only existing on leaf nodes.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(algo=StemmaNJ(distance = levenshtein, rooting_method = \"none\"))\n</code></pre>"},{"location":"algorithms/#parameters_1","title":"Parameters","text":"<ul> <li><code>distance</code>: The distance metric to be used to calculate the distance between texts. This can be any function that takes at least 2 strings as arguments and returns a float. For the distance function to be valid, it must respect the following 2 constraints:<ul> <li>The distance of 2 identical strings must be equal to 0 <code>distance(\"test\", \"test\") == 0</code>.</li> <li>No matter the order the strings are placed in as parameters, the result must be identical <code>distance(\"test1\", \"test2\") == distance(\"test2\", \"test1\")</code>.</li> </ul> </li> <li><code>rooting_method</code>: As the Neighbor-Joining algorithm produces unrooted trees, this parameter specifies the rooting method to be used on the resulting tree. The currently supported rooting methods are:<ul> <li>none: This will return the last agglomerated node as the root of the tree.</li> <li>midpoint-dist: This is an implementation of the midpoint rooting method, and will return the tree with the root being the midpoint of the longest distance between all leaf nodes in the tree. This method takes into account the length of the tree edges. This is the default method used by the algorithm.</li> <li>midpoint-edge: Similar to the previous method, although all edge lengths are considered to be equal to 1.</li> </ul> </li> </ul> <p>Reference</p> <p>Saitou N, Nei M (July 1987). \u201cThe neighbor-joining method: a new method for reconstructing phylogenetic trees\u201d. In: Mol. Biol. Evol.</p>"},{"location":"algorithms/#rhm","title":"RHM","text":"<p>RHM is a stochastic algorithm which functions by randomly rearranging a given tree and only keeping the changes that reduce a certain cost function. This means that the heart of RHM algorithm is the various cost functions of which it is comprised. </p> <p>This method can only produce bifid trees with existing manuscripts only existing on leaf nodes.</p> <p>Currently, this algorithm can only build the stemma by reading the outputted dot file produced by the compute method.</p> <p>In the case that multiple iterations of the algorithm are run (strap&gt;1) then the stemma that is returned by the compute method is the last one calculated.</p> <pre><code>stemma = Stemma(folder_path=\"path_to_the_folder\")\nstemma.compute(algo=StemmaRHM(nb_opti = 1, strap = 1, segment_size = 10, keep_dot = True))\n</code></pre>"},{"location":"algorithms/#parameters_2","title":"Parameters","text":"<ul> <li><code>nb_opti</code>: The number of optimisation iterations to run through for each run of the algorithm.</li> <li><code>strap</code>: The number of times the algorithm will be run and the results outputted. Due to the stochastic nature of the algorithm, this parameter is used to enable the calculation of an average performance.</li> <li><code>segment_size</code>: The size of the segments that the texts will be divided up into. The number represents the number of words per segment.</li> <li><code>keep_dot</code>: Boolean indicating if the dot files should be removed once the edge.txt files have been produced.</li> </ul> <p>Reference</p> <p>Roos, Teemu, Tuomas Heikkil\u00e4, and Petri Myllym\u00e4ki (Jan. 2006). \u201cA Compression-Based Method for Stemmatic Analysis.\u201d In: Frontiers in Artificial Intelligence and Applications 141, pp. 805\u2013806.</p>"},{"location":"algorithms/#how-to-implement-a-custom-algorithm","title":"How to implement a custom algorithm","text":"<p>All algorithms inherit from the class StemmaAlgo. Therefore, any custom algorithm must inherit from this class. </p> <p>The algorithm object must also possess a compute method which must take the path to the folder containing the stemma txt file as first parameter. This compute method must return the root of the stemma tree which will be passed to the _root attribute of the stemma as shown below. This root must be an object that inherits from the ManuscriptInTreeBase object.</p> <p>The code section bellow shows the section of the stemma compute method that is executed when building as stemma using an algorithm.</p> <pre><code>elif algo:\nself._root = algo.compute(folder_path=self.folder_path, **kargs)\nself._text_lookup = self._root.build_text_lookup()\nfor text in self.text_lookup.values():\nif isinstance(text, ManuscriptInTree):\ntext._text = Utils.load_text(f\"{self.folder_path}/{text.label}.txt\")\nself._fitted = True\n</code></pre> <p>Then following example shows the implementation of the compute method for the dummy algorithm.</p> <pre><code>def compute(self, folder_path: str, width: Union[int, None] = None) -&gt; ManuscriptInTree:\nif width:\nself._width = width\nif not isinstance(width, int):\nraise ValueError(\"Parameter width must be of type int.\")\nsuper().compute(folder_path)\nreturn ManuscriptInTree(parent=None, recursive=Utils.dict_from_edge(edge_list=self._build_edges(self._build_random_levels())), \ntext_list=Utils.get_text_list(folder_path))\n</code></pre> <p>As it can be seen in the above example in order to instantiate a tree the algorithm need only produce a dictionary representation of the stemma tree and passe it as an argument to the <code>recursive</code> parameter of a manuscript object.</p> <p>In order to facilitate the production of this dictionary, a list of edges can be passed to the <code>dict_from_edge</code> method from the Utils class that will construct the dictionary. This list of edges must be specified in the following format:</p> <pre><code>[[\"1\", \"2\"], [\"1\", \"3\"], [\"2\", \"4\"], [\"2\", \"5\"], [\"3\", \"6\"], [\"3\", \"7\"]]\n</code></pre> <p>The labels on the left are considered parens and the labels on the right children. For an edge list to be valid, it must possess a single root. Therefore, only a single label can only be present on the left of all the edges.</p>"},{"location":"outputs/","title":"Generated outputs","text":"<p>StemmaBench generates two outputs within the <code>output_folder</code> specified in the command line:</p> <ol> <li>A file <code>edge.txt</code> which represents the tree as a set of node.</li> <li>A set of file <code>*.txt</code> which contain the copied text and which number represent their hierarchy in the tree. <code>0</code> is the first text, then <code>0_0</code> and <code>0_1</code> are its descendants, then <code>0_0_0</code> and <code>0_0_1</code> are the descendants of <code>0_0</code> in a bifid tree fashion, etc.</li> </ol> <p>Furthermore, if the <code>rate</code> parameter of the <code>missing_manuscripts</code> option is greater than zero, an additional folder called <code>missing_tradition</code> is created within the <code>output_folder</code> specified in the command line. This folder includes:</p> <ul> <li>A file named <code>edge_missing.txt</code> containing the edges connecting the non-missing manuscripts still available.</li> <li>A collection of <code>*.txt</code> files with the remaining manuscripts in the tradition. These files exclude any manuscripts that were deleted during the process.</li> </ul>"},{"location":"variants/","title":"Scribal behavior modelization","text":"<p>StemmaBench relies on the assumption that scribal behavior can be successfully modelized using probabilistic processes.</p> <p>The parameters are specified in a YAML file, such as:</p> <pre><code>meta:\nlanguage: en\nvariants:\nletters:\nmispell:\nlaw: Bernouilli\nrate: 0.05\nargs:\nspecific_rates:\na:\nb: 0.01\nc: 0.02\nb:\na: 0.02\nc: 0.01\nwords:\nsynonym:\nlaw: Bernouilli\nrate: 0.1\nomit:\nlaw: Bernouilli\nrate: 0.05\nsentences:\nduplicate:\nargs:\nnbr_words: 2\nlaw: Bernouilli\nrate: 0.1\nstemma:\ndepth: 2\nwidth:\nlaw: Uniform\nmin: 2\nmax: 4\nmissing_manuscripts:\nlaw: Bernouilli\nrate: 0.5\n</code></pre>"},{"location":"variants/#scribal-dependent-variants","title":"Scribal dependent variants","text":"<p>For now, the following possible variants are modelized using a Bernouilli law, meaning that each time a word is \"generated\" (i.e. each time a scribe \"writes\" a word) the word is modified with probability p (else it remains the same).</p> <p>Possible variants are:</p>"},{"location":"variants/#at-the-letter-level","title":"At the letter level","text":"<p>This section is used to customize the probability of a letter being modified according to a custom rate given by the user in the specific_rates field.</p> <ul> <li> <p>rate: Represents the total probability of a letter being modified.</p> <p>[!WARNING] Rate include values of specific_rates. If the sum of the specific_rates is greater than rate an error will be raised.</p> </li> <li> <p>specific_rates: Represents the probability of a letter being substituted with another letter. If letter is not in specific_rates the probability of that letter to be substituted is equal to : (rate-sum(specific_rates))/(length(alphabet)-length(specific_rates)).</p> </li> </ul>"},{"location":"variants/#exemple-of-specific_rates","title":"Exemple of specific_rates","text":"<p>We define the following YAML file: <pre><code>meta:\nlanguage: en\nvariants:\nletters:\nmispell:\nlaw: Bernouilli\nrate: 0.05\nargs:\nspecific_rates:\na:\nb: 0.01\nc: 0.02\nb:\na: 0.01\nc:\na: 0.02\nwords:\nsynonym:\nlaw: Bernouilli\nrate: 0.1\nomit:\nlaw: Bernouilli\nrate: 0.05\nsentences:\nduplicate:\nargs:\nnbr_words: 2\nlaw: Bernouilli\nrate: 0.1\nstemma:\ndepth: 2\nwidth:\nlaw: Uniform\nmin: 2\nmax: 4\nmissing_manuscripts:\nlaw: Bernouilli\nrate: 0.5\n</code></pre></p> <p>This configuration generates the following matrix of probabilities for misspelling letters: <pre><code>a:\na: 0.95\nb: 0.02\nc: 0.001\nd: 0.001\ne: 0.001\nf: 0.001\ng: 0.001\nh: 0.001\ni: 0.001\nj: 0.001\nk: 0.001\nl: 0.001\nm: 0.001\nn: 0.001\no: 0.001\np: 0.001\nq: 0.001\nr: 0.001\ns: 0.001\nt: 0.001\nu: 0.001\nv: 0.001\nw: 0.001\nx: 0.001\ny: 0.001\nz: 0.001\nb:\na: 0.01\nb: 0.95\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nc:\na: 0.02\nb: 0.001\nc: 0.95\nd: 0.001\ne: 0.001\nf: 0.001\ng: 0.001\nh: 0.001\ni: 0.001\nj: 0.001\nk: 0.001\nl: 0.001\nm: 0.001\nn: 0.001\no: 0.001\np: 0.001\nq: 0.001\nr: 0.001\ns: 0.001\nt: 0.001\nu: 0.001\nv: 0.001\nw: 0.001\nx: 0.001\ny: 0.001\nz: 0.001\nd:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.95\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\ne:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.95\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nf:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.95\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\ng:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.95\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nh:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.95\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\ni:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.95\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nj:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.95\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nk:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.95\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nl:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.95\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nm:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.95\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nn:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.95\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\no:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.95\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\np:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.95\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nq:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.95\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nr:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.95\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\ns:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.95\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nt:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.95\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nu:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.95\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nv:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.95\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.002\nw:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.95\nx: 0.002\ny: 0.002\nz: 0.002\nx:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.95\ny: 0.002\nz: 0.002\ny:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.95\nz: 0.002\nz:\na: 0.002\nb: 0.002\nc: 0.002\nd: 0.002\ne: 0.002\nf: 0.002\ng: 0.002\nh: 0.002\ni: 0.002\nj: 0.002\nk: 0.002\nl: 0.002\nm: 0.002\nn: 0.002\no: 0.002\np: 0.002\nq: 0.002\nr: 0.002\ns: 0.002\nt: 0.002\nu: 0.002\nv: 0.002\nw: 0.002\nx: 0.002\ny: 0.002\nz: 0.95\n</code></pre></p>"},{"location":"variants/#at-the-letter-level_1","title":"At the letter level","text":"<ul> <li>Mispell: The probability of a letter being substituted is decided according to a Bernouilli distribution with the probability rate. The substitution is done by drawing a random letter according to the probability matrix defined above.</li> </ul>"},{"location":"variants/#at-the-word-level","title":"At the word level","text":"<ul> <li>Word omission: The word is omitted.</li> <li>Synonym: A synonym is randomly drawn from NLTK semantic net.</li> </ul>"},{"location":"variants/#at-the-sentence-level","title":"At the sentence level","text":"<ul> <li>Duplication: A word can be copied several times. A random location in the sentence is selected, and words are duplicated by a configurable number of words (for now, fixed).</li> </ul>"},{"location":"variants/#scribal-independent-variants","title":"Scribal independent variants","text":""},{"location":"variants/#fragmentation","title":"Fragmentation","text":""},{"location":"variants/#missing-manuscripts","title":"Missing manuscripts","text":"<p>In the StemmaBench package, the concept of missing manuscripts is modeled using a probabilistic process governed by a p-parameter Bernoulli distribution. After having generated the whole tradition, a proportion p of the manuscripts are selected (with equiprobability) and deleted from the tradition. This simulates the loss of certain manuscripts over time.</p> <p>[!WARNING IN RAM]</p> <p>Currently, the missing manuscript feature is only available after dumping the stemma to a folder using the dump() method.</p>"},{"location":"variants/#supported-languages","title":"Supported languages","text":"<p>Two languages are currently supported: - English; - Greek.</p> <p>Additional support for biblical Hebrew is underway.</p>"}]}